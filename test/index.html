<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    * {
      margin: 0;
    }

    .box {
      position: relative;
      width: 100%;
      height: 156px;
      background: red;
    }

    .item {
      position: absolute;
      display: inline-block;
      left: 0;
      top: 0;
      height: 78px;
      width: 78px;
      transition: all 1s;
      background: blue;
    }

    .item1 {
      left: 78px;
      background: green;
    }

    .item2 {
      left: 156px;
      background: orange;
    }

    .item3 {
      left: 234px;
      background: pink;
    }

    .item4 {
      left: 0px;
      top: 78px;
      background: azure;
    }
  </style>
</head>

<body>
  <div class="box">
    <!-- <div class="item">0</div>
    <div class="item item1">1</div>
    <div class="item item2">2</div>
    <div class="item item3">3</div>
    <div class="item item4">4</div> -->
  </div>
  <script>
    class Wrapper {
      constructor(el) {
        this.el = el
        this.slots = []
        this.lastIdx = -1
        this.elementSize = 78
        this.col = Math.floor(this.el.offsetWidth / this.elementSize)
        this.row = 1

        // ;[].slice.call(el.children).forEach((child, idx) => {
        //   let obj = new Element(child)
        //   obj.idx = idx
        //   this.slots.push({
        //     x: obj.x,
        //     y: obj.y,
        //     el: obj
        //   })
        // })
      }

      createElement () {
        let idx = ++this.lastIdx
        let div = document.createElement('div')
        div.className = 'item item' + idx
        div.textContent = idx
        this.el.appendChild(div)
        
        let obj = new Element(div)
        obj.idx = idx
        obj.moveEvent = this._moveEventHandle.bind(this)
        obj.endEvent = this._endEventHandle.bind(this)

        this.slots.push({
          x: obj.x,
          y: obj.y,
          el: obj
        })

        this.row = Math.ceil(this.slots.length / this.col)
      }

      _moveEventHandle (source) {
        let idx = this._judge(source.x, source.y)
          if (typeof idx === 'number' && idx !== source.idx) {
            if (idx < source.idx) {
              for (let i = source.idx; i > idx; i--) {
                let current = this.slots[i]
                let last = this.slots[i - 1]
                last.el.x = current.x
                last.el.y = current.y
                last.el.idx = current.el.idx
                current.el = last.el
              }
            } else {
              for (let i = source.idx; i < idx; i++) {
                let current = this.slots[i]
                let next = this.slots[i + 1]
                next.el.x = current.x
                next.el.y = current.y
                next.el.idx = current.el.idx
                current.el = next.el
              }
            }

            source.idx = idx
            this.slots[idx].el = source
        }
      }

      _endEventHandle (source) {
        source.endX = this.slots[source.idx].x
        source.endY = this.slots[source.idx].y
      }

      // 边界处理还是有问题
      _judge (x, y) {
        let maxX = (this.col - 1) * this.elementSize
        let maxY = (this.row - 1) * this.elementSize

        if (x < 0 && y < 0) {
          return 0
        } else if (x > maxX && y < 0) {
          if (this.slots.length >= this.col) return this.col - 1
          else return this.slots.length - 1
        } else if (x < 0 && y > maxY) {
          return (this.row - 1) * this.col
        } else if (x > maxX && y > maxY) {
          let idx = this.row * this.col - 1
          if (idx >= this.slots.length) return idx - this.col
          else return idx
        } else if (y < 0) {
          let end = this.slots.length >= this.col ? this.col : this.slots.length
          for (let i = 0; i < end; i++) {
            if (x >= this.slots[i].x && x < this.slots[i + 1].x) {
              return i
            }
          }
        } else if (y > maxY) {
          let start = (this.row - 1) * this.col
          let end = this.row * this.col
          for (let i = start; i < end; i++) {
            let slot1 = this.slots[i - this.col]
            let slot2 = this.slots[i - this.col + 1]
            if (x >= slot1.x && x < slot2.x) {
              if (this.slots[i]) return i
              else return i - this.col
            }
          }
        }
        for (let i = 0, len = (this.row - 1) * this.col; i < len; i++) {
          if ((i + 1) % this.col === 0) continue
          let slot1 = this.slots[i]
          let slot2 = this.slots[i + 1]
          if (x > slot1.x && x < slot2.x && y > slot1.y && y < slot2.y) {
            return i
          }
        }
      }
    }

    class Element {
      constructor(el) {
        this.el = el

        this.endX = null
        this.endY = null

        this.moveEvent = null
        this.endEvent = null

        let isTransition = false
        Object.defineProperty(this, 'isTransition', {
          get() {
            return isTransition
          },
          set(value) {
            isTransition = value
            let pointerEvents = isTransition ? 'none' : 'auto'
            this.el.style.pointerEvents = pointerEvents
          }
        })

        Object.defineProperty(this, 'x', {
          get() {
            return this.el.offsetLeft
          },
          set(value) {
            this.el.style.left = value + 'px'
          }
        })

        Object.defineProperty(this, 'y', {
          get: function () {
            return this.el.offsetTop
          },
          set: function (value) {
            this.el.style.top = value + 'px'
          }
        })

        el.addEventListener('touchstart', this)
        el.addEventListener('touchmove', this)
        el.addEventListener('touchend', this)
        el.addEventListener('transitionEnd', this)
        el.addEventListener('webkitTransitionEnd', this)
        el.addEventListener('oTransitionEnd', this)
        el.addEventListener('MSTransitionEnd', this)
      }

      handleEvent(e) {
        switch (e.type) {
          case 'touchstart':
            this._start(e)
            break
          case 'touchmove':
            this._move(e)
            break
          case 'touchend':
            this._end(e)
            break
          case 'transitionEnd':
          case 'webkitTransitionEnd':
          case 'oTransitionEnd':
          case 'MSTransitionEnd':
            this._transitionEnd(e)
            break
        }
      }

      moveTo (x, y) {
        this.el.style.transitionDuration = '1s'

        this.x = x
        this.y = y
      }

      _start (event) {
        this.el.style.zIndex = 2

        let touch = event.touches[0]
        this.startX = parseInt(this.el.offsetLeft)
        this.startY = parseInt(this.el.offsetTop)
        this._pageX = touch.pageX
        this._pageY = touch.pageY
      }

      _move(event) {
        this.el.style.transitionDuration = '0s'

        let touch = event.touches[0]
        let deltaX = touch.pageX - this._pageX
        let deltaY = touch.pageY - this._pageY
        this.x = this.startX + deltaX
        this.y = this.startY + deltaY

        if (this.moveEvent) this.moveEvent(this)
      }

      _end(event) {
        if (this.endEvent) this.endEvent(this)

        this.isTransition = true
        this.el.style.transitionDuration = '1s'

        if (this.endX !== null) this.x = this.endX
        else this.x = this.startX
        if (this.endY !== null) this.y = this.endY
        else this.y = this.startY

        this.endX = null
        this.endY = null
      }

      _transitionEnd(event) {
        this.isTransition = false
      }
    }


    var box = document.querySelector('.box')
    var wrapper = new Wrapper(box)
    wrapper.createElement()
    wrapper.createElement()
    wrapper.createElement()
    wrapper.createElement()
    wrapper.createElement()
  </script>
</body>

</html>