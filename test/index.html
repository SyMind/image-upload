<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    * {
      margin: 0;
    }

    .box {
      position: relative;
      width: 100%;
      height: 156px;
      background: red;
    }

    .item {
      position: absolute;
      display: inline-block;
      left: 0;
      top: 0;
      height: 78px;
      width: 78px;
      transition: all 1s;
      background: blue;
    }

    .item1 {
      background: green;
    }

    .item2 {
      background: orange;
    }

    .item3 {
      background: pink;
    }

    .item4 {
      background: azure;
    }
  </style>
</head>

<body>
  <div class="box">
    <!-- <div class="item">0</div>
    <div class="item item1">1</div>
    <div class="item item2">2</div>
    <div class="item item3">3</div>
    <div class="item item4">4</div> -->
  </div>
  <script>
    class Wrapper {
      constructor(el) {
        this.el = el
        this.slots = []
        this.lastIdx = -1
        this.elementSize = 78
        this.col = Math.floor(this.el.offsetWidth / this.elementSize)
        this.row = 0
      }

      createElement (el) {
        let idx = ++this.lastIdx
        let div = document.createElement('div')
        div.className = 'item item' + idx
        div.style.left = (this.slots.length % this.col) * this.elementSize
        div.style.top = (this.slots.length % this.col === 0 ? this.row++ : this.row - 1) * this.elementSize
        div.appendChild(el)
        this.el.appendChild(div)
        this.el.style.height = this.row * this.elementSize + 'px'

        let obj = new Element(div)
        obj.idx = idx
        obj.moveEvent = this._moveEventHandle.bind(this)
        obj.endEvent = this._endEventHandle.bind(this)

        this.slots.push({
          x: obj.x,
          y: obj.y,
          el: obj
        })

        this.row = Math.ceil(this.slots.length / this.col)
      }

      _moveEventHandle(source) {
        let idx = this._judge(source.x, source.y)
        if (typeof idx === 'number' && idx !== source.idx) {
          if (idx < source.idx) {
            for (let i = source.idx; i > idx; i--) {
              let current = this.slots[i]
              let last = this.slots[i - 1]
              last.el.x = current.x
              last.el.y = current.y
              last.el.idx = current.el.idx
              current.el = last.el
            }
          } else {
            for (let i = source.idx; i < idx; i++) {
              let current = this.slots[i]
              let next = this.slots[i + 1]
              next.el.x = current.x
              next.el.y = current.y
              next.el.idx = current.el.idx
              current.el = next.el
            }
          }

          source.idx = idx
          this.slots[idx].el = source
        }
      }

      _endEventHandle(source) {
        source.endX = this.slots[source.idx].x
        source.endY = this.slots[source.idx].y
      }

      _judge(x, y) {
        let extra = 0.5 * this.elementSize
        let minX = - extra
        let maxX = (this.col - 1) * this.elementSize + extra
        let minY = - extra
        let maxY = (this.row - 1) * this.elementSize + extra
        if (this.row >= 2) maxY = (this.row - 2) * this.elementSize + extra

        if (x < minX && y < minY) {
          return 0
        } else if (x > maxX && y < minY) {
          if (this.slots.length >= this.col) return this.col - 1
          else return this.slots.length - 1
        } else if (x < minX && y > maxY) {
          return (this.row - 1) * this.col
        } else if (x > maxX && y > maxY) {
          let idx = this.row * this.col - 1
          if (idx >= this.slots.length) return idx - this.col
          else return idx
        } else if (y < minY) {
          let end = this.slots.length >= this.col ? this.col : this.slots.length
          for (let i = 0; i < end; i++) {
            if (x >= this.slots[i].x - extra && x < this.slots[i].x + extra) {
              return i
            }
          }
        } else if (y > maxY) {
          let start = (this.row - 1) * this.col
          let end = this.row * this.col
          for (let i = start; i < end; i++) {
            let slot = this.slots[i]
            let result = i
            if (!this.slots[i]) {
              slot = this.slots[i - this.col]
              let result = i - this.col
            }
            if (x >= slot.x - extra && x < slot.x + extra) {
              return result
            }
          }
        }
        for (let i = 0, len = this.slots.length; i < len; i++) {
          let slot = this.slots[i]
          if (x > slot.x - extra && x < slot.x + extra && y > slot.y - extra && y < slot.y + extra) {
            return i
          }
        }
      }
    }

    class Element {
      constructor(el) {
        this.el = el

        this.endX = null
        this.endY = null

        this.moveEvent = null
        this.endEvent = null

        let isTransition = false
        Object.defineProperty(this, 'isTransition', {
          get() {
            return isTransition
          },
          set(value) {
            isTransition = value
            let pointerEvents = isTransition ? 'none' : 'auto'
            this.el.style.pointerEvents = pointerEvents
          }
        })

        Object.defineProperty(this, 'x', {
          get() {
            return this.el.offsetLeft
          },
          set(value) {
            this.el.style.left = value + 'px'
          }
        })

        Object.defineProperty(this, 'y', {
          get: function () {
            return this.el.offsetTop
          },
          set: function (value) {
            this.el.style.top = value + 'px'
          }
        })

        el.addEventListener('touchstart', this)
        el.addEventListener('touchmove', this)
        el.addEventListener('touchend', this)
        el.addEventListener('transitionEnd', this)
        el.addEventListener('webkitTransitionEnd', this)
        el.addEventListener('oTransitionEnd', this)
        el.addEventListener('MSTransitionEnd', this)
      }

      handleEvent(e) {
        switch (e.type) {
          case 'touchstart':
            this._start(e)
            break
          case 'touchmove':
            this._move(e)
            break
          case 'touchend':
            this._end(e)
            break
          case 'transitionEnd':
          case 'webkitTransitionEnd':
          case 'oTransitionEnd':
          case 'MSTransitionEnd':
            this._transitionEnd(e)
            break
        }
      }

      moveTo(x, y) {
        this.el.style.transitionDuration = '500ms'

        this.x = x
        this.y = y
      }

      _start(event) {
        this.el.style.zIndex = 2

        let touch = event.touches[0]
        this.startX = parseInt(this.el.offsetLeft)
        this.startY = parseInt(this.el.offsetTop)
        this._pageX = touch.pageX
        this._pageY = touch.pageY
      }

      _move(event) {
        this.el.style.transitionDuration = '0ms'

        let touch = event.touches[0]
        let deltaX = touch.pageX - this._pageX
        let deltaY = touch.pageY - this._pageY
        this.x = this.startX + deltaX
        this.y = this.startY + deltaY

        if (this.moveEvent) this.moveEvent(this)
      }

      _end(event) {
        if (this.endEvent) this.endEvent(this)

        this.isTransition = true
        this.el.style.transitionDuration = '500ms'

        if (this.endX !== null) this.x = this.endX
        else this.x = this.startX
        if (this.endY !== null) this.y = this.endY
        else this.y = this.startY

        this.endX = null
        this.endY = null
      }

      _transitionEnd(event) {
        this.isTransition = false
      }
    }

    var box = document.querySelector('.box')
    var wrapper = new Wrapper(box)
    wrapper.createElement()
    wrapper.createElement()
    wrapper.createElement()
    wrapper.createElement()
    wrapper.createElement()
  </script>
</body>

</html>
